---
title: "Ceci n'est pas une %>%: <br>Exploring Your Data with R"
author: ""

date: "Fall, 2015"
output: 
  ioslides_presentation: 
    smaller: yes
    widescreen: yes
    css: slideStyles.css
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr); library(magrittr)
```

# Data Discovery in R


## Goals
- Introduce newer approaches to data wranging, scrubbing, manipulation etc.

- Show the benefits of piping code

- Put it all together with some newer visualization packages 


## Outline 
- Newer approaches to data wrangling
    - Introduction to plyr dplyr and tidyr
    - Subsetting rows
    - Subsetting columns
    - Reshaping data
    - Generating new data
    - Grouping and summarizing

- Nothin's gonna stop the flow
    - Piping with the magrittr package

- Quick interactive visualizations
    - Using *yr packages, piping and visualization
    - ggvis
    - htmlwidgets
    
    

# Newer approaches to data wrangling
## Newer approaches to data wrangling
- A starting example

- Let's say we want to select from our data only the following variables
    - The variables X1:X10, which are not all together, and there are many more 'X' columns
    - The variables Y1 and Y2, which are the only Y variables in the data
    - Any variable that starts with XYZ
    
- How might we go about this?

## Some base R approaches

- Tedious, or typically two steps just to get the columns you want.

```{r, eval=FALSE, echo=TRUE}
newData = oldData[,c(1,2,3,4, etc.)]
newData = oldData[,c('X1', 'X2', etc.)]
cols = c(paste0('X', 1:10), 'Y1', 'Y2', grep(colnames(oldData), '^XYZ', value=T))
newData = oldData[,cols]
newData = subset(oldData, select = cols)
```

## More
- What if you also want observations where Z is 'Yes', Q is 'No', and only the last 50 of those results, ordered by Y1 (descending)?

```{r2, eval=FALSE, echo=TRUE}
newData = newData[oldData$Z == 'Yes' & oldData$Q == 'No',]
newData = tail(newData, 50)
newData = newdata[order(newdata$Y1, decreasing=T),]
```

## An alternative

```{r, eval=FALSE, echo=TRUE}
newData = oldData %>% 
  filter(Z == 'Yes', Q == 'No') %>% 
  select(num_range('X', 1:10), contains('Y'), starts_with('XYZ')) %>% 
  tail(50) %>% 
  arrange(desc(Y1))
```

## An alternative

- Even though the former is probably more concise than many would do on their own, it still is: 
    - noisier
    - less legible
    - less amenable to additional data changes
    - requires esoteric knowledge (e.g. regular expressions)

# Another example...

## Start with a string, end with a map

```{r, eval=FALSE, echo=TRUE}
packs = c('magrittr', 'rvest', 'dplyr', 'stringr' ,'leaflet', 'ggvis')
sapply(packs, library, character.only=T)

# a color palette to be used later
pal = colorNumeric(palette = c('Red', 'White', 'Navy'), test0$popDiff)  

wikiURL = 'https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population'

# Let's go!
wikiURL %>% 
  html %>% 
  html_node(css='.wikitable.sortable') %>% 
  html_table %>% 
  sapply(function(x) repair_encoding(as.character(x), 'UTF-8')) %>%
  data.frame %>%  
  mutate(City = str_replace(City, '\\[(.*?)\\]', ''),
         latlon = sapply(str_split(Location, '/'), last), 
         latlon = str_extract_all(latlon, '[-|[0-9]]+\\.[0-9]+'), 
         lat = sapply(latlon, first),
         lon = sapply(latlon, nth, 2), 
         population2014 = as.numeric(str_replace_all(X2014.estimate, ',', '')),
         population2010 = as.numeric(str_replace_all(X2010.Census, ',', '')),
         popDiff  = round(population2014/population2010 - 1, 2)*100) %>% 
```

## Cont'd.

```{r, eval=FALSE, echo=TRUE}
  select(-latlon, -Location) %>% 
  filter(as.numeric(as.character(X2014.rank)) <= 50)  %>% 
  leaflet %>% 
  addProviderTiles("CartoDB.DarkMatterNoLabels") %>% 
  setView(-94, 35, zoom = 4) %>% 
  addCircleMarkers(~lon, ~lat,
                   radius=  ~scales::rescale(popDiff, c(1, 10)),
                   fillColor=  ~pal(popDiff), stroke = FALSE, fillOpacity = .85,
                   popup=  ~paste(City, paste0(popDiff, '%')))
```



## And the result...

```{r, eval=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
# packs = c('magrittr', 'rvest', 'dplyr', 'stringr' ,'leaflet', 'ggvis')
# sapply(packs, library, character.only=T)
library(magrittr); library(rvest); library(dplyr); library(dplyr); library(stringr)
library(leaflet)

'https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population' %>% 
  html %>% 
  html_node(css='.wikitable.sortable') %>% 
  html_table %>% 
  sapply(function(x) repair_encoding(as.character(x), 'UTF-8')) %>%
  data.frame %>%  
  mutate(City = str_replace(City, '\\[(.*?)\\]', ''),
         latlon = sapply(str_split(Location, '/'), last), 
         latlon = str_extract_all(latlon, '[-|[0-9]]+\\.[0-9]+'), 
         lat = sapply(latlon, first),
         lon = sapply(latlon, nth, 2), 
         population2014 = as.numeric(str_replace_all(X2014.estimate, ',', '')),
         population2010 = as.numeric(str_replace_all(X2010.Census, ',', '')),
         popDiff  = round(population2014/population2010 - 1, 2)*100) %T>% 
  select(-latlon, -Location) %>% 
  filter(as.numeric(as.character(X2014.rank)) <= 50)  %>% 
  leaflet %>% 
  addProviderTiles("CartoDB.DarkMatterNoLabels") %>% 
  setView(-94, 35, zoom = 4) %>% 
  addCircleMarkers(~lon, ~lat,
                   radius=  ~scales::rescale(popDiff, c(1, 10)),
                   fillColor=  ~colorNumeric(palette = c('Red', 'White', 'Navy'), popDiff)(popDiff), 
                   stroke = FALSE, fillOpacity = .85,
                   popup=  ~paste(City, paste0(popDiff, '%')))
```


## 

- In the interests of your own code, the previous is not recommended.
- It serves as an illustration of what's possible.

## Newer approaches to data wrangling
- Over the past couple of years, a handful of packages have been put out that make data management within R noticeably easier
- We will focus on plyr, dplyr, tidyr, and maybe reshape2
- But others, e.g. data.table, take different approaches and may be useful as well
- Newer visualization packages take advantage of these approaches to data manipulation

# A provocation

```{r, eval=T, echo=T}
c('Ceci', "n'est", 'pas', 'une', 'pipe!') %>%
{
  .. <-  . %>%
    if (length(.) == 1)  .
    else paste(.[1], '%>%', ..(.[-1]))
  ..(.)
} 
```

# Generating New Data
## Generating New Data

As is often the case, there are times when we want to calculate new variables based upon existing variable.

```{r, eval=FALSE}
library(rvest); library(dplyr); library(magrittr); library(tidyr)

statsTab = read_html("http://www.basketball-reference.com/leagues/NBA_2015_totals.html?lid=header_seasons") %>% 
  html_nodes("table#totals") %>% 
  html_table %>% 
  data.frame %>% 
  filter(Rk != "Rk")

statsTab[, 6:30] = sapply(statsTab[, 6:30], as.numeric)

glimpse(statsTab)
  
statsTab = statsTab %>% 
  mutate(trueShooting = round(PTS / (2 * (FGA + (.44 * FTA))), 2),
         effectiveFG = round((FG + (.5 * X3P)) / FGA, 2), 
         shootingDif = trueShooting - FG.)

summary(statsTab)

statsTab %>% arrange(desc(effectiveFG)) %>% head

```


Sometimes we want to combine (or split) variables

```{r, eval=FALSE}
statsTab %>% 
  unite_("posTeam", c("Pos", "Tm"))
```

We will go a bit deeper into this in bit.

# Filtering Observations
## Filtering Observations

Recall this bit of code?

```{r, eval=FALSE}
statsTab = read_html("http://www.basketball-reference.com/leagues/NBA_2015_totals.html?lid=header_seasons") %>% 
  html_nodes("table#totals") %>% 
  html_table %>% 
  data.frame %>% 
  filter(Rk != "Rk")
```

You will notice the filter line at the end.

We sometimes want to see a very specific portion of the data.

```{r, eval=FALSE}
statsTab %>% 
  filter(Age > 35, Pos == "SF" | Pos == "PF")
```


```{r, eval=FALSE}
statsTab %>% 
  unite_("posTeam", c("Pos", "Tm")) %>% 
  filter(posTeam == "PF_SAS") %>% 
  arrange(desc(PTS/PF))
```

# Selecting Variables
## Selecting Variables

There are times when you do not want to look at the entire dataset, but instead want to focus on a few key variables.

Although this is easily handled in base (as shown earlier), it is more clearly accomplished using select in dplyr.

```{r, eval=FALSE}
scoringDat = statsTab %>% 
  select(Player, Tm, Pos, MP, trueShooting, effectiveFG, PTS)

summary(scoringDat)

```

That works great, but now we need to drop some of those variables to look at correlations.

```{r, eval=FALSE}
scoringDat %>% 
  select(-Player, -Tm, -Pos) %>% 
  na.omit %>% 
  cor %T>%
  corrplot::corrplot.mixed()
```



# Reshaping Data
## Reshaping Data

Depending upon your analytical or visualization needs, sometimes you need to reshape your data.

Reshaping can take many forms. You might need to reshape your data from wide format to long format.

Or, maybe you need to split or combine variables.

Either way, R has you covered

## Wide to Long

We are going to load up the reshape2 package to make this data go from wide to long

```{r, eval=FALSE}

library(reshape2); library(ggvis)

ggvisCleanTheme = axis_props(grid = list(stroke = "white"), 
                             axis = list(stroke = "white"))

statsTab %>% 
  select(Tm, FG., X3P, X2P.1, trueShooting, effectiveFG) %>%
  rename(fieldGoalPerc = FG., threePointPerc = X3P, twoPointPerc = X2P.1) %>% 
  mutate(threePointPerc = threePointPerc/100) %>% 
  melt(., id.vars = "Tm", 
       measure.vars = c("fieldGoalPerc", "threePointPerc", "twoPointPerc", 
                        "trueShooting", "effectiveFG"), 
       variable.name = "vitalInfo") %>%
  group_by(Tm, vitalInfo) %>%
  summarize(avg = mean(value)) %>% 
  ggvis(~Tm, ~avg) %>% 
  group_by(vitalInfo) %>%
  layer_points(fill = ~vitalInfo) %>% 
  group_by(vitalInfo) %>% 
  layer_lines(stroke = ~vitalInfo) %>% 
  add_axis("x", properties = ggvisCleanTheme)
```

# Grouping and Summarizing Data
## Grouping and Summarizing Data

When working with data, a very common task is to look at descriptive statistics for various groups.

Using the various functions within dplyr and magrittr makes this very easy.

```{r, eval=FALSE}

scoringDat %>% 
  group_by(Pos) %>% 
  summarize(meanTrueShooting = mean(trueShooting, na.rm = TRUE))

scoringDat %>% 
  filter(Pos == "C") %>% 
  arrange(desc(trueShooting)) %>% 
  filter(PTS > median(PTS)) %>% 
  select(trueShooting, PTS) %T>%
  plot() %$% 
  cor(trueShooting, PTS)

```




# Your Turn
## Your Turn
?state.x77

Using one pipe sequence 

1. convert state.x77 (a base R object) to a data frame
2. create a new variable called 'Region' that is equal to state.region
2. create a new variable called 'State' that is equal to state.name
3. select only if Population is greater than 1000 (thousands)
3. select Region and variables beginning with I
4. group by region
5. summarise Income, Illiteracy or Both, using the mean function

## Your Turn
```{r, eval=FALSE}
state.x77 %>% 
  data.frame %>% 
  mutate(Region = state.region,
         State = state.name) %>% 
  filter(Population > 1000) %>% 
  select(Region, starts_with('I')) %>% 
  group_by(Region) %>% 
  summarise(meanInc=mean(Income),
            meanIll=mean(Illiteracy))
```

# More with pipes
## More with pipes

- Recap thus far
- %>% : Passes the prior to the function after the pipe
    - x %>% f same as f(x)
- Example

```{r}
iris %>% head
head(iris)
```


## More with pipes


- \%\$\%  : Exposes the names in the prior to the function after
    - x %\$% y(a, b)  same as y(x\$a, x\$b)
- Example

```{r}
iris %$% lm(Sepal.Length ~ Sepal.Width)
```

## More with pipes
- %T>% : Passes the prior to the function after the pipe and what follows
    - x %T>% y %>% z == x %>% y 
- Example

```{r, fig.width=3, fig.height=3}
iris %>% 
  select(Sepal.Length, Sepal.Width) %T>% 
  plot %>%
  summary
```

## More with pipes
- Unfortunately the T pipe does not allow for printable results.

- Works
```{r, eval=FALSE, }
iris %>% select(Sepal.Length, Sepal.Width) %T>% plot %>% summary
```

- Provides no summary.
```{r, eval=FALSE}
iris %>% select(Sepal.Length, Sepal.Width) %T>% summary %>% plot
```

- Very limiting in my opinion

## More with pipes
- %<>% : assigns to former object the operations that follow

- Example

```{r}
iris2 = iris
iris2 %>% summary
iris2 %<>% rnorm(10)
iris2
```



# Piping to other functions
## Piping to other functions

## Wrap up


<table class='acknowledge'>
<tr>
<td style='font-size:12pt'>Michael Clark <br> Advanced Research Computing <br> Consulting for Statistics, Computing & Analytics Research <br> University of Michigan</td>

<td style='text-align:right; font-size:12pt'>Seth Berry<br> Notre Dame Research<br> Center for Social Research<br> University of Notre Dame</td>
</tr>
</table>




## Further
